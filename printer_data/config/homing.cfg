
# Note you may need to add the following to your printer.cfg somewhere (without the comments of course) for the Kinematic position stuff below to work.
# From :  https://github.com/EricZimmerman/Voron24/blob/PreKlippain/macros/helpers/homing.cfg
#  and :  https://docs.vorondesign.com/tuning/sensorless.html 

[force_move]
enable_force_move: True


[gcode_macro _HOME_X]
gcode:
    RESPOND MSG="homing.cfg: _HOME_X" COLOR="success"
      
    {% set RUN_CURRENT_X = printer.configfile.settings['tmc5160 stepper_x'].run_current|float %}
    {% set RUN_CURRENT_Y = printer.configfile.settings['tmc5160 stepper_y'].run_current|float %}
    {% set HOME_CURRENT = 0.49 %} ### 0.49 
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CURRENT}
    #SET_TMC_CURRENT STEPPER=stepper_y CURRENT={HOME_CURRENT}

    {% if printer.toolhead.position.y < 40 %}
      _UNSAFE_Y_MOVE
    {% endif %}
    
    SET_KINEMATIC_POSITION X=-5
    G91
    G0 X+5 F1200
    
    G4 P2000   # wait 2 seconds  
    M400       # wait to finish all pending moves/process the buffer
    
    G90
    G28 X
    
    # Move in position for y homing
    G1 X50 F9000
    
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CURRENT_X}
    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={RUN_CURRENT_Y}

[gcode_macro _HOME_Y]
gcode:
    RESPOND MSG="homing.cfg: _HOME_Y" COLOR="success"
  
    {% set RUN_CURRENT_X = printer.configfile.settings['tmc5160 stepper_x'].run_current|float %}
    {% set RUN_CURRENT_Y = printer.configfile.settings['tmc5160 stepper_y'].run_current|float %}
    {% set HOME_CURRENT = 0.49 %}
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={HOME_CURRENT}
    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={HOME_CURRENT}
    
    G90 
    G28 Y

    G4 P2000
    M400     
    
    # Wait just a second‚Ä¶ (give StallGuard registers time to clear)
    SET_TMC_CURRENT STEPPER=stepper_x CURRENT={RUN_CURRENT_X}
    SET_TMC_CURRENT STEPPER=stepper_y CURRENT={RUN_CURRENT_Y}

[homing_override]
axes: xyz
gcode:
  RESPOND MSG="homing.cfg: homing_ovveride"
  
  ###! STATUS_HOMING  # Stealthburner LED update
    
  {% set home_all = 'X' not in params and 'Y' not in params and 'Z' not in params %}

  # Enregistrer la position actuelle dans une variable
  {% set pos = printer.toolhead.position %}
  {% set axismax = printer.toolhead.axis_maximum %}
  
  {% set parked = printer["gcode_macro GLOBALS_V"].extruder_parked %}
  {% if parked == 1 %}
    _UNSAFE_OUT_OF_PARK  ##  Disable for autospeed 

  {% else %}
    {% if pos.z <= ( axismax.z - 20) %}
      # SET_KINEMATIC_POSITION Z=0
      # G1 Z15 F1200                 # move up to be shure
      M400
    {% else %}
          # do nothing, z may be alreay very hight 
     {% endif %}
   {% endif %}
  
   {% if home_all or 'X' in params %}  
     _HOME_X
   {% endif %}
  
   {% if home_all or 'Y' in params %}
     _HOME_Y
   {% endif %}
  
   {% if home_all or 'Z' in params %}
     RESPOND MSG="homing.cfg: HOME Z" COLOR="success"
     G90
     G1 X160 Y160 F9000

    ## ***************************************************************************
    ## this section from the original [probe] as for probing with TAP without EDDY
    {% set PROBE_TEMP = 150 %}
    {% set MAX_TEMP = PROBE_TEMP + 5 %}
    {% set ACTUAL_TEMP = printer.extruder.temperature %}
    {% set TARGET_TEMP = printer.extruder.target %}

    {% if TARGET_TEMP > PROBE_TEMP %}
        { action_respond_info('Extruder temperature target of %.1fC is too high, lowering to %.1fC' % (TARGET_TEMP, PROBE_TEMP)) }
        M109 S{ PROBE_TEMP }
    {% else %}
        # Temperature target is already low enough, but nozzle may still be too hot.
        {% if ACTUAL_TEMP > MAX_TEMP %}
            { action_respond_info('Extruder temperature %.1fC is still too high, waiting until below %.1fC' % (ACTUAL_TEMP, MAX_TEMP)) }
            TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={ MAX_TEMP }
        {% endif %}
    {% endif %}
    ## ***************************************************************************

     G28 Z  ## home Z with TAP without EDDY

     G90
     G1 Z10 F1500

   {% endif %}
  
###! STATUS_READY  # Stealthburner LED update


[gcode_macro _CG28]
description: Homing only if necessary
gcode:
    RESPOND MSG="homing.cfg: _CG28" COLOR="success"
    {% if "xyz" not in printer.toolhead.homed_axes %}
        G28
    {% endif %}

[gcode_macro MESH_CALIBRATE]
gcode:
    BED_MESH_CLEAR
    PROBE=eddy_probe

# [gcode_macro QUAD_GANTRY_LEVEL]
# rename_existing: _QUAD_GANTRY_LEVEL
# gcode:
#     # If QGL is not applied, first run a course calibration
#     {% if printer.quad_gantry_level.applied == False %}
#          RESPOND TYPE=command COLOR=warning MSG="Calling _QUAD_GANTRY_LEVEL HORIZONTAL_MOVE_Z=8 RETRY_TOLERANCE=1.0"
#         _QUAD_GANTRY_LEVEL HORIZONTAL_MOVE_Z=8 RETRY_TOLERANCE=1.0
#     {% endif %}
    
#     # then perform fine QGL down to desired spec
#     # this has to be a separate macro call so the results of the above call will be visible!
#     _FINE_QUAD_GANTRY_LEVEL
#     RESPOND TYPE=command COLOR=success MSG="QGL success"

[gcode_macro QUAD_GANTRY_LEVEL]
rename_existing: _QUAD_GANTRY_LEVEL
gcode:
    AUTO_QGL

[gcode_macro _FINE_QUAD_GANTRY_LEVEL]
gcode:
    QGL_RANGE
    M400 
    G4 P2000

    {% if printer.quad_gantry_level.applied == True %}
       RESPOND TYPE=command COLOR=warning MSG="Fine QGL , Calling _QUAD_GANTRY_LEVEL  HORIZONTAL_MOVE_Z=4.0"
        _QUAD_GANTRY_LEVEL HORIZONTAL_MOVE_Z=4.0 
    {% else %}
       RESPOND TYPE=command COLOR=warning MSG="Fine QGL called without calling coarse QGL first!"
       RESPOND TYPE=command COLOR=warning MSG="Calling _QUAD_GANTRY_LEVEL  HORIZONTAL_MOVE_Z=4.0"
       _QUAD_GANTRY_LEVEL  HORIZONTAL_MOVE_Z=4.0 
    {% endif %}
    
[gcode_macro QGL_RANGE]
variable_value: 0
gcode:
    RESPOND TYPE=command COLOR=info MSG="QGL_RANGE: value={value}"

[gcode_macro AUTO_QGL]
description: "Auto QGL with adaptive horizontal_move_z"
gcode:
    # 1) Coarse pass
    RESPOND TYPE=command MSG="AUTO_QGL: coarse pass..."

    _QUAD_GANTRY_LEVEL HORIZONTAL_MOVE_Z=8 RETRY_TOLERANCE=1.0

    G4 P500

    # Klipper expose la d√©viation via printer.quad_gantry_level.probe_deltas
    {% set deltas = printer.quad_gantry_level.probe_deltas %}
    {% if deltas|length == 4 %}
        {% set range = (deltas|max) - (deltas|min) %}
    {% else %}
        {% set range = 0.0 %}
    {% endif %}

    RESPOND TYPE=command MSG="AUTO_QGL: first-pass skew = {range}"

    # 2) Adapt horizontal_move_z
    {% set hz_raw = range * 2 %}
    {% set hz = [hz_raw, 4.0]|max %}

    RESPOND TYPE=command MSG="AUTO_QGL: using horizontal_move_z = {hz}"

    # 3) Fine pass
    _QUAD_GANTRY_LEVEL HORIZONTAL_MOVE_Z={hz}

    RESPOND TYPE=command MSG="AUTO_QGL: DONE."
    
# [gcode_macro FIRST_QGL_PASS]
# description: "Single-pass corner probing for SMART_QGL"
# gcode:
#     # Z_TILT_ADJUST respects runtime RETRY_TOLERANCE
#     # Setting it very high forces exactly ONE pass
#     Z_TILT_ADJUST RETRY_TOLERANCE=10.0

# Option B ‚Äî Keep SMART_QGL separate
# Use it only when needed:
# Before mesh calibration
# After mechanical work
# After moving printer
# Before prints
# This is safer if you sometimes want to run QGL ‚Äúnormally‚Äù.
# Recommended if:
# You want to debug QGL behavior sometimes
# You still test your adaptive logic
# You want to compare original QGL vs SMART_QGL
# üü© Option C ‚Äî Create BOTH
# Keep:
# QUAD_GANTRY_LEVEL
# SMART_QGL
# But add a helper macro:
# [gcode_macro QGL]
# gcode:
#     SMART_QGL
# Now:
# QGL ‚Üí adaptive
# QUAD_GANTRY_LEVEL ‚Üí raw original
# Both easy to call

# [gcode_macro _QGL_BASE]
# # rename_existing: QUAD_GANTRY_LEVEL
# gcode:
#     _QUAD_GANTRY_LEVEL {params}

## [gcode_macro SMART_QGL] renamed [gcode_macro QUAD_GANTRY_LEVEL]
    # # Run full QGL normally
    # QUAD_GANTRY_LEVEL
    # ...

# [gcode_macro SMART_QGL]
# gcode:
#     QUAD_GANTRY_LEVEL
#     G4 P1500

#     {% set r = printer["gcode_macro QGL_RANGE"].value|float %}
#     {% set limit = 0.02 %}  # exemple: 0.02 mm

#     {% if r <= 0 %}
#         RESPOND TYPE=command COLOR=warning MSG="SMART_QGL: pas de range, QGL standard"
#         QUAD_GANTRY_LEVEL
#         RESPOND TYPE=command COLOR=success MSG="SMART_QGL complete hz=4.0 (fallback)"
#     {% elif r > limit %}
#         RESPOND TYPE=command COLOR=error MSG="SMART_QGL: gantry skew {r} > seuil {limit}, abort"
#         {action_raise_error("SMART_QGL: gantry skew au-dessus du seuil")}
#     {% else %}
#         {% set hz_raw = r * 2 %}
#         {% set hz = [hz_raw, 4.0]|max %}

#         RESPOND TYPE=command COLOR=warning MSG="SMART_QGL: first range {r}  hz_raw={hz_raw}"
#         RESPOND TYPE=command COLOR=info MSG="SMART_QGL: second pass hz={hz}"

#         QUAD_GANTRY_LEVEL HORIZONTAL_MOVE_Z={hz}

#         RESPOND TYPE=command COLOR=success MSG="SMART_QGL complete hz={hz}"
#     {% endif %}


# # [gcode_macro QUAD_GANTRY_LEVEL]
# [gcode_macro SMART_QGL]
# description: "Adaptive QGL with skew check"
# gcode:
#     # -------------------------------------------
#     # 0) User threshold for gantry skew (mm)
#     # -------------------------------------------
#     {% set threshold = 0.05 %}

#     # -------------------------------------------
#     # 1) First full QGL pass (your firmware always multi-passes)
#     # Python monitor captures FIRST 'Probed points range'
#     # -------------------------------------------
#     QUAD_GANTRY_LEVEL

#     # Wait for Python script to store QGL_RANGE.value
#     M400
#     G4 P1500

#     {% set r = printer["gcode_macro QGL_RANGE"].value|float %}

#     {% if r <= 0 %}
#         RESPOND TYPE=command COLOR=warning MSG="SMART_QGL: No range captured"
#         {action_raise_error("SMART_QGL aborted")}
#     {% endif %}

#     # -------------------------------------------
#     # 2) Abort if gantry skew exceeds threshold
#     # -------------------------------------------
#     {% if r > threshold %}
#         RESPOND TYPE=command COLOR=error MSG="SMART_QGL: Gantry skew {r} mm > threshold {threshold} mm"
#         {action_raise_error("Gantry skew too large. Mechanical check required.")}
#     {% endif %}

#     # -------------------------------------------
#     # 3) Compute hz = max(4, 2*r)
#     # -------------------------------------------
#     {% set hz_raw = r * 2 %}
#     {% set hz = [hz_raw, 4.0]|max %}

#     RESPOND TYPE=command COLOR=warning MSG="SMART_QGL: first-pass range = {r} raw2 = {hz_raw}"
#     RESPOND TYPE=command COLOR=info MSG="SMART_QGL: using horizontal_move_z = {hz}"

#     # -------------------------------------------
#     # 4) Second QGL with corrected hz
#     # -------------------------------------------
#     QUAD_GANTRY_LEVEL HORIZONTAL_MOVE_Z={hz}

#     RESPOND TYPE=command COLOR=success MSG="SMART_QGL complete (hz={hz})"

[gcode_macro SHOW_HOMING_STATE]
gcode: 
    {% set homing_status = printer.toolhead.homed_axes %}
    m118 { homing_status }

    {% if 'x' in homing_status %} 
       M118 X: Homed 
    {% else %} 
      M118 X: Not Homed
    {% endif %}

    {% if 'y' in homing_status %} 
       M118 Y: Homed 
    {% else %} 
      M118 Y: Not Homed
    {% endif %}

    {% if 'z' in homing_status %} 
       M118 Z: Homed 
    {% else %} 
      M118 Z: Not Homed
    {% endif %}
